// RUQ and RSQ
// range_update(l,r,x) a[l],a[l+1]...a[r-1]をxに更新
// get_sum(l,r) a[l],a[l+1]...a[r-1]の和を取得
struct SegTree {
    ll len;
    vector<ll> data, lazy;
    vector<bool> lazyFlag;

    SegTree(ll sz) {
        len = 1;
        while (len < sz) len <<= 1;
        data.assign(2 * len, 0); // 初期値0
        lazy.assign(2 * len, 0);
        lazyFlag.assign(2 * len, false);
    }

    void eval(ll k, ll sl, ll sr) {
        if (lazyFlag[k]) {
            data[k] = lazy[k] * (sr - sl);
            if (sr - sl > 1) {
                lazy[2 * k] = lazy[k];
                lazy[2 * k + 1] = lazy[k];
                lazyFlag[2 * k] = lazyFlag[2 * k + 1] = true;
            }
            lazyFlag[k] = false;
        }
    }

    void range_update(ll l, ll r, ll x, ll sl = 0, ll sr = -1, ll k = 1) {
        if (sr == -1) sr = len;
        eval(k, sl, sr);
        if (r <= sl || sr <= l) return;
        if (l <= sl && sr <= r) {
            lazy[k] = x;
            lazyFlag[k] = true;
            eval(k, sl, sr);
        } else {
            ll sm = (sl + sr) / 2;
            range_update(l, r, x, sl, sm, 2 * k);
            range_update(l, r, x, sm, sr, 2 * k + 1);
            data[k] = data[2 * k] + data[2 * k + 1];
        }
    }

    ll get_sum(ll l, ll r, ll sl = 0, ll sr = -1, ll k = 1) {
        if (sr == -1) sr = len;
        eval(k, sl, sr);
        if (r <= sl || sr <= l) return 0;
        if (l <= sl && sr <= r) return data[k];
        ll sm = (sl + sr) / 2;
        return get_sum(l, r, sl, sm, 2 * k) + get_sum(l, r, sm, sr, 2 * k + 1);
    }
};